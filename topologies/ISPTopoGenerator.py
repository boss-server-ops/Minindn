import argparse
import os

def generate_isp_conf(agg_num, fwd_per_agg, pro_per_fwd, bw, agg_loss, fwd_loss, pro_loss):
    """生成ISP拓扑配置文件，con0作为核心层节点"""
    nodes = ["con0:_"]  # 消费者节点兼核心节点
    links = []
    
    # 生成汇聚层节点
    total_agg = agg_num
    for i in range(total_agg):
        nodes.append(f"agg{i}:_")
    
    # 生成转发层节点 (forwarder)
    total_fwd = total_agg * fwd_per_agg
    for i in range(total_fwd):
        nodes.append(f"fwd{i}:_")
    
    # 生成生产者节点
    total_pro = total_fwd * pro_per_fwd
    for i in range(total_pro):
        nodes.append(f"pro{i}:_")
    
    # 核心(con0)到汇聚层连接
    for agg_id in range(agg_num):
        links.append(f"con0:agg{agg_id} bw={bw} delay=0 max_queue_size=10000 loss={agg_loss}")
    
    # 汇聚到转发层连接
    for agg_id in range(total_agg):
        start_fwd = agg_id * fwd_per_agg
        for fwd_id in range(start_fwd, start_fwd + fwd_per_agg):
            links.append(f"agg{agg_id}:fwd{fwd_id} bw={bw} delay=0 max_queue_size=10000 loss={fwd_loss}")
    
    # 转发层到生产者连接
    for fwd_id in range(total_fwd):
        start_pro = fwd_id * pro_per_fwd
        for pro_id in range(start_pro, start_pro + pro_per_fwd):
            links.append(f"fwd{fwd_id}:pro{pro_id} bw={bw} delay=0 max_queue_size=10000 loss={pro_loss}")
    
    conf = f"""[nodes]
{"\n".join(nodes)}
[links]
{"\n".join(links)}
# Generated by ISP generator"""
    return conf

def generate_test_script(agg_loss, fwd_loss, pro_loss):
    return f"""import os
import argparse
from time import sleep
from mininet.log import setLogLevel, info
from minindn.minindn import Minindn
from minindn.util import MiniNDNCLI
from minindn.apps.app_manager import AppManager
from minindn.apps.nfd import Nfd
from minindn.apps.nlsr import Nlsr
from minindn.apps.application import Application

if __name__ == '__main__':
    # 解析命令行参数
    parser = argparse.ArgumentParser(description='运行ISP网络实验')
    parser.add_argument('--runtime', type=int, default=600,
                      help='实验运行时间（秒，默认600）')
    parser.add_argument('--work-dir', default='./isp-workdir',
                      help='工作目录')
    parser.add_argument('--agg-loss', type=float, default={agg_loss},
                      help='汇聚层丢包率覆盖（默认{agg_loss}%）')
    parser.add_argument('--fwd-loss', type=float, default={fwd_loss},
                      help='转发层丢包率覆盖（默认{fwd_loss}%）')
    parser.add_argument('--pro-loss', type=float, default={pro_loss},
                      help='生产者层丢包率覆盖（默认{pro_loss}%）')
    args = parser.parse_args()
    
    setLogLevel('info')
    Minindn.cleanUp()
    Minindn.verifyDependencies()
    ndn = Minindn()
    ndn.start()
    
    info('网络丢包率配置:\\n')
    info(f'汇聚层丢包率: {{args.agg_loss}}%\\n')
    info(f'转发层丢包率: {{args.fwd_loss}}%\\n')
    info(f'生产者层丢包率: {{args.pro_loss}}%\\n')
    
    # 启动基础服务
    info('Starting NFD\\n')
    AppManager(ndn, ndn.net.hosts, Nfd)
    info('Starting NLSR\\n')
    AppManager(ndn, ndn.net.hosts, Nlsr)
    sleep(30)  # 延长路由收敛时间
    
    # 节点分类
    consumer = ndn.net['con0']  # 核心节点兼消费者
    aggregators = [h for h in ndn.net.hosts if h.name.startswith('agg')]
    forwarders = [h for h in ndn.net.hosts if h.name.startswith('fwd')]
    producers = [h for h in ndn.net.hosts if h.name.startswith('pro')]
    
    # 启动生产者
    producer_path = os.path.abspath('./putapps/producer')
    for pro in producers:
        info(f'Starting Producer {{pro.name}}\\n')
        Application(pro).start(
            f'{{producer_path}} --prefix /{{pro.name}}', 
            f'{{pro.name}}.log'
        )
        sleep(1)
    
    # 启动汇聚层服务
    aggregator_path = os.path.abspath('./aggapps/aggregator')
    for agg in aggregators:
        info(f'Starting Aggregator {{agg.name}}\\n')
        Application(agg).start(
            f'{{aggregator_path}} --prefix /{{agg.name}}',
            f'{{agg.name}}.log'
        )
        sleep(1)
    
    # 配置核心节点缓存策略
    info(f'Configuring Core {{consumer.name}}\\n')
    consumer.cmd('nfd-strategy-set / /localhost/nfd/strategy/best-route')
    consumer.cmd('nfdc cs config capacity 100000')  # 设置大缓存容量
    
    # 通告路由
    info('Advertising routes\\n')
    for node in producers + aggregators + forwarders:
        node.cmd(f'nlsrc advertise /{{node.name}}')
        sleep(0.5)
    
    # 启动消费者(就是con0)
    info(f'Starting Consumer on {{consumer.name}}\\n')
    consumer_path = os.path.abspath('./catapps/consumer')
    Application(consumer).start(consumer_path, 'consumer.log')
    
    # 实验运行时间
    info(f'实验将运行 {{args.runtime}} 秒...\\n')
    sleep(args.runtime)
    MiniNDNCLI(ndn.net)
    ndn.stop()
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="ISP拓扑及测试脚本生成器")
    parser.add_argument("--agg-num", type=int, required=True, 
                      help="汇聚节点数量（例如4）")
    parser.add_argument("--fwd-per-agg", type=int, required=True,
                      help="每个汇聚节点连接的转发节点数（例如6）") 
    parser.add_argument("--pro-per-fwd", type=int, default=2,
                      help="每个转发节点连接的生产者数（默认2）")
    parser.add_argument("-b", "--bw", type=int, default=1000,
                      help="基础带宽（Mbps，默认1000）")
    parser.add_argument("--agg-loss", type=float, default=0.2,
                      help="汇聚层链路丢包率（百分比，默认0.2%）")
    parser.add_argument("--fwd-loss", type=float, default=0.5,
                      help="转发层链路丢包率（百分比，默认0.5%）")
    parser.add_argument("--pro-loss", type=float, default=1.0,
                      help="生产者链路丢包率（百分比，默认1.0%）")
    
    args = parser.parse_args()
    
    # 参数校验
    if any(v < 1 for v in [args.agg_num, args.fwd_per_agg]):
        print("错误：节点数量必须大于0")
        exit(1)
    
    if any(v < 0 for v in [args.agg_loss, args.fwd_loss, args.pro_loss]):
        print("错误：丢包率不能为负数")
        exit(1)
    
    # 生成拓扑文件
    conf_content = generate_isp_conf(
        args.agg_num,
        args.fwd_per_agg, args.pro_per_fwd, args.bw,
        args.agg_loss, args.fwd_loss, args.pro_loss
    )
    
    # 生成文件名 (包含丢包率信息)
    conf_filename = f"isp_a{args.agg_num}f{args.fwd_per_agg}_loss{args.agg_loss}-{args.fwd_loss}-{args.pro_loss}.conf"
    
    # 创建必要的目录并写入配置文件
    try:
        with open(conf_filename, 'w') as f:
            f.write(conf_content)
        
        # 确保examples目录存在
        os.makedirs("../examples", exist_ok=True)
        
        # 生成测试脚本
        with open("../examples/ISPTest.py", 'w') as f:
            f.write(generate_test_script(args.agg_loss, args.fwd_loss, args.pro_loss))
        
        print(f"生成成功！\n配置文件：{conf_filename}\n测试脚本：../examples/ISPTest.py")
        print(f"运行命令：python ../examples/ISPTest.py --work-dir ./isp-workdir ./topologies/{conf_filename}")
        print(f"您可以通过 --runtime 参数设置实验运行时间，例如：")
        print(f"python ../examples/ISPTest.py --runtime 300 --work-dir ./isp-workdir ./topologies/{conf_filename}")
    except PermissionError:
        print("错误：写入文件失败，请检查目录权限")
        print("尝试以下命令解决权限问题：")
        print("1. sudo chmod -R u+w ../examples")
        print("2. sudo chmod u+w ./")
    except Exception as e:
        print(f"错误：{str(e)}")