import argparse
import os

def generate_conf(k, bw):
    nodes = []
    links = []
    
    # 根节点
    nodes.append("con0:_")
    
    # 中间层（agg节点）
    for layer in range(1, k-1):
        num_agg = 2 ** layer
        for x in range(num_agg):
            nodes.append(f"agg{x}:_")
    
    # 叶节点（pro节点）
    num_pro = 2 ** (k-1)
    for x in range(num_pro):
        nodes.append(f"pro{x}:_")
    
    # 生成链接
    for parent_layer in range(k-1):
        child_layer = parent_layer + 1
        num_parents = 2 ** parent_layer if parent_layer != 0 else 1
        for x in range(num_parents):
            parent_name = "con0" if parent_layer == 0 else f"agg{x}"
            child_prefix = "agg" if child_layer < k-1 else "pro"
            child1_num = 2 * x
            child2_num = 2 * x + 1
            child1 = f"{child_prefix}{child1_num}"
            child2 = f"{child_prefix}{child2_num}"
            links.append(f"{parent_name}:{child1} bw={bw} delay=0 max_queue_size=10000 loss=0")
            links.append(f"{parent_name}:{child2} bw={bw} delay=0 max_queue_size=10000 loss=0")
    
    conf = "[nodes]\n" + "\n".join(nodes) + "\n\n[links]\n" + "\n".join(links) + "\n\n# Generated by script"
    return conf

def generate_test_script():
    return """import os
from time import sleep
from mininet.log import setLogLevel, info
from minindn.minindn import Minindn
from minindn.util import MiniNDNCLI
from minindn.apps.app_manager import AppManager
from minindn.apps.nfd import Nfd
from minindn.apps.nlsr import Nlsr
from minindn.apps.application import Application

if __name__ == '__main__':
    setLogLevel('info')
    Minindn.cleanUp()
    Minindn.verifyDependencies()
    ndn = Minindn()
    ndn.start()
    
    info('Starting NFD\\n')
    AppManager(ndn, ndn.net.hosts, Nfd)
    info('Starting NLSR\\n')
    AppManager(ndn, ndn.net.hosts, Nlsr)
    sleep(20)
    
    # 获取节点
    consumer = ndn.net['con0']
    aggregators = [h for h in ndn.net.hosts if h.name.startswith('agg')]
    producers = [h for h in ndn.net.hosts if h.name.startswith('pro')]
    
    # 启动生产者
    producer_path = os.path.abspath('./putapps/producer')
    for pro in producers:
        info(f'Starting Producer {pro.name}\\n')
        Application(pro).start(f'{producer_path} --prefix /{pro.name}', f'{pro.name}.log')
        sleep(5)
    
    # 启动聚合器
    agg_path = os.path.abspath('./aggapps/aggregator')
    for agg in aggregators:
        info(f'Starting Aggregator {agg.name}\\n')
        Application(agg).start(f'{agg_path} --prefix /{agg.name}', f'{agg.name}.log')
        sleep(5)
    
    # 通告路由
    for node in producers + aggregators:
        node.cmd(f'nlsrc advertise /{node.name}')
        sleep(2)
    
    # 启动消费者
    info('Starting Consumer\\n')
    consumer_path = os.path.abspath('./catapps/consumer')
    Application(consumer).start(consumer_path, 'consumer.log')
    
    sleep(300)
    MiniNDNCLI(ndn.net)
    ndn.stop()
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="生成满二叉树拓扑和测试脚本")
    parser.add_argument('layers', type=int, help="树的层数（如3层生成4个叶节点）")
    parser.add_argument('--bw', type=int, default=100, help="链路带宽（默认100Mbps）")
    args = parser.parse_args()
    
    k = args.layers
    bw = args.bw
    if k < 2:
        print("层数必须大于等于2")
        exit(1)
    
    # 生成配置文件
    conf = generate_conf(k, bw)
    with open(f'binary_tree_{k}.conf', 'w') as f:
        f.write(conf)
    
    # 生成测试脚本
    os.makedirs('../examples', exist_ok=True)
    with open('../examples/BinaryTest.py', 'w') as f:
        f.write(generate_test_script())
    
    print(f"生成成功！配置文件: binary_tree_{k}.conf，测试脚本: ../examples/BinaryTest.py")