import argparse
import os

def generate_dcn_conf(agg_num, pro_per_agg, bw, loss):
    nodes = ["con0:_"]
    links = []
    
    # 生成Aggregator节点
    for i in range(agg_num):
        nodes.append(f"agg{i}:_")
    
    # 生成Producer节点
    total_pro = agg_num * pro_per_agg
    for i in range(total_pro):
        nodes.append(f"pro{i}:_")
    
    # 核心到汇聚层连接
    for agg_id in range(agg_num):
        links.append(f"con0:agg{agg_id} bw={bw} delay=0 max_queue_size=10000 loss={loss}")
    
    # 汇聚层到生产者连接
    for agg_id in range(agg_num):
        start_pro = agg_id * pro_per_agg
        end_pro = start_pro + pro_per_agg
        for pro_id in range(start_pro, end_pro):
            links.append(f"agg{agg_id}:pro{pro_id} bw={bw} delay=0 max_queue_size=10000 loss={loss}")
    
    conf = f"""[nodes]
{"\n".join(nodes)}
[links]
{"\n".join(links)}
# Generated by DCN generator"""
    return conf

def generate_test_script():
    return """import os
from time import sleep
from mininet.log import setLogLevel, info
from minindn.minindn import Minindn
from minindn.util import MiniNDNCLI
from minindn.apps.app_manager import AppManager
from minindn.apps.nfd import Nfd
from minindn.apps.nlsr import Nlsr
from minindn.apps.application import Application

if __name__ == '__main__':
    setLogLevel('info')
    Minindn.cleanUp()
    Minindn.verifyDependencies()
    ndn = Minindn()
    ndn.start()
    
    # 启动基础服务
    info('Starting NFD\\n')
    AppManager(ndn, ndn.net.hosts, Nfd)
    info('Starting NLSR\\n')
    AppManager(ndn, ndn.net.hosts, Nlsr)
    sleep(20)  # 等待路由收敛
    
    # 节点分类
    consumer = ndn.net['con0']
    aggregators = [h for h in ndn.net.hosts if h.name.startswith('agg')]
    producers = [h for h in ndn.net.hosts if h.name.startswith('pro')]
    
    # 启动生产者
    producer_path = os.path.abspath('./putapps/producer')
    for pro in producers:
        info(f'Starting Producer {pro.name}\\n')
        Application(pro).start(
            f'{producer_path} --prefix /{pro.name}', 
            f'{pro.name}.log'
        )
        sleep(2)
    
    # 启动聚合器
    aggregator_path = os.path.abspath('./aggapps/aggregator')
    for agg in aggregators:
        info(f'Starting Aggregator {agg.name}\\n')
        Application(agg).start(
            f'{aggregator_path} --prefix /{agg.name}',
            f'{agg.name}.log'
        )
        sleep(2)
    
    # 通告路由
    info('Advertising routes\\n')
    for node in producers + aggregators:
        node.cmd(f'nlsrc advertise /{node.name}')
        sleep(1)
    
    # 启动消费者
    info('Starting Consumer\\n')
    consumer_path = os.path.abspath('./catapps/consumer')
    Application(consumer).start(consumer_path, 'consumer.log')
    
    # 实验运行时间
    sleep(300)
    MiniNDNCLI(ndn.net)  # 进入交互模式
    ndn.stop()
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="DCN拓扑及测试脚本生成器")
    parser.add_argument("--agg-num", type=int, required=True, 
                      help="汇聚层节点数量（例如4）")
    parser.add_argument("--pro-per-agg", type=int, required=True,
                      help="每个汇聚节点连接的生产者数量（例如8）")
    parser.add_argument("--bw", type=int, default=100,
                      help="链路带宽（Mbps，默认100）")
    parser.add_argument("--loss", type=float, default=0.0,
                      help="链路丢包率（0.0-1.0，默认0.0）")
    
    args = parser.parse_args()
    
    # 参数校验
    if args.agg_num < 1 or args.pro_per_agg < 1:
        print("错误：节点数量必须大于0")
        exit(1)
    if not 0.0 <= args.loss <= 1.0:
        print("错误：丢包率必须在0.0到1.0之间")
        exit(1)
    
    # 生成拓扑文件
    conf_content = generate_dcn_conf(args.agg_num, args.pro_per_agg, args.bw, args.loss)
    conf_filename = f"dcn_agg{args.agg_num}_pro{args.pro_per_agg}_bw{args.bw}_loss{args.loss}.conf"
    with open(conf_filename, 'w') as f:
        f.write(conf_content)
    
    # 生成测试脚本
    os.makedirs("../examples", exist_ok=True)
    with open("../examples/DCNTest.py", 'w') as f:
        f.write(generate_test_script())
    
    print(f"生成成功！\n配置文件：{conf_filename}\n测试脚本：../examples/DCNTest.py")
    print("运行命令：python ../examples/DCNTest.py")